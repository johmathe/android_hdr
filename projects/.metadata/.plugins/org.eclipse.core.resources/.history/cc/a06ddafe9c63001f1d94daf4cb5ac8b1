package hdr;

import java.awt.Color;

import jjil.core.RgbImage;
import jjil.core.RgbVal;


public class HdrAlgorithm {
	private RgbImage inIm[];
	private RgbImage outIm;
	private SfpImage hdrIm;
	private double exposures[];
	// Epsilon used for stability of the logarithm.
	private static final double d = 0.00001f;
	// Correction coefficient.
	private static final double a = 0.18f;
	public HdrAlgorithm(RgbImage[] images, double exp[]) {
		this.inIm = images;
		if (images == null) {
			throw new Error();
		}
		this.hdrIm = new SfpImage(images[0].getWidth(), images[0].getHeight(), 0);
		this.exposures = exp;
	}
	public boolean ready() {
		/* checks if input data is correct, we need at least 2 images */
		if (inIm != null) {
			if (inIm.length > 1) {
				return true;
			}
		}
		return false;
	}
	
	public SfpImage Merge() {
		if (!ready()) {
			throw new Error("Not enough data to merge the pictures.");
		}		
		float[] hdrInternal = hdrIm.getData();
		int rgbData[][] = new int[inIm.length][];
		int totalLength = hdrIm.getHeight()*hdrIm.getWidth(); 
		for (int i=0; i<inIm.length; i++) {
			rgbData[i] = inIm[i].getData();
		}
		int nColor = 3;
		boolean properlyExposed[][] = new boolean[nColor][totalLength];
		boolean overExposed[][] = new boolean[nColor][totalLength];
		boolean underExposed[][] = new boolean[nColor][totalLength];
		int properlyExposedCount[][] = new int[nColor][totalLength];
		int c[] = new int[nColor];
		for (int p=0; p<totalLength; p++) {
			// over each input image
			for (int i=0; i<inIm.length; i++) {
				// Normalize the values bt [0 255]
				// Retrieve 3 color channels
				
				c[0] = RgbVal.getR(rgbData[i][p])-Byte.MIN_VALUE;
				c[1] = RgbVal.getG(rgbData[i][p])-Byte.MIN_VALUE;
				c[2] = RgbVal.getB(rgbData[i][p])-Byte.MIN_VALUE;
				
				for (int j=0; j<c.length; j++) {
					
					if(IsOverExposed(c[j])) {
						overExposed[j][p] |= true;
				
					} else if(IsUnderExposed(c[j])) {
						underExposed[j][p] |= true;
						
					} else {
						properlyExposed[j][p] |= true;
						properlyExposedCount[j][p] += 1;
						hdrInternal[3*p+j] += c[j]/exposures[i];
						
					}
				}
			}
		}
		float minProperlyExposed = Float.POSITIVE_INFINITY;
		for (int j=0;j<nColor;j++) {
			for (int p=0; p<totalLength; p++) {
				if(properlyExposed[j][p] && hdrInternal[3*p+j]<minProperlyExposed) {
					minProperlyExposed = hdrInternal[3*p+j];
				}
			}
		}
		float maxProperlyExposed = Float.NEGATIVE_INFINITY;
		for (int j=0;j<nColor;j++) {
			for (int p=0; p<totalLength; p++) {
				if(properlyExposed[j][p] && hdrInternal[3*p+j]>maxProperlyExposed) {
					maxProperlyExposed = hdrInternal[3*p+j];
				}
			}
		}
		System.out.println("maxProperlyExposed"+maxProperlyExposed+"minProperlyExposed"+minProperlyExposed);
		for (int j=0;j<nColor;j++) {
			for (int p=0; p<totalLength; p++) {

				hdrInternal[3*p+j] /= (float)(Math.max(1, properlyExposedCount[j][p]));
				//System.out.println(hdrInternal[3*p+j]);
				if (!properlyExposed[j][p]) {
					if (underExposed[j][p] && !overExposed[j][p]) {
						hdrInternal[3*p+j] = minProperlyExposed;
					} else if (overExposed[j][p] && !underExposed[j][p]) {
						hdrInternal[3*p+j] = maxProperlyExposed;
					} else if (overExposed[j][p] && underExposed[j][p]) {
						//TODO(assign neighbor value)
						System.out.println("over and under");
						hdrInternal[3*p+j] = 200;
					} else {
						throw new Error("not properly exposed and neither under or overexposed pixel");
					}
				}
			}
		}
		return hdrIm;
	}
	
	static private boolean IsOverExposed(int v) {
		// TODO(johmathe): define as class member.
		int tMax = 240;
		if(v > tMax) {
			return true;
		}
		return false;
	}
	static private boolean IsUnderExposed(int v) {
		int tMin = 35;
		if(v < tMin) {
			return true;
		}
		return false;
	}

	public RgbImage Tonemap() {
		float[] hdrInternal = hdrIm.getData();
		if (hdrInternal == null) {
			throw new Error("HDR image not initialized");
		}
		hdrIm = RGBtoHSL(hdrIm);
		System.out.print("min: "+Min(hdrInternal)+" max: "+Max(hdrInternal));
		outIm = ComputeNewLuminanceMap(hdrIm);
		return outIm;
	}
	
	static private float Max(float in[]) {
		float max = Float.NEGATIVE_INFINITY;
		if (in == null) {
			throw new Error();
		}
		for (int i=0; i<in.length; i++) {
			if (in[i] > max) {
				max = in[i];	
			}
		}
		return max;
	}
	static private int Max(int in[]) {
		int max = Integer.MIN_VALUE;
		if (in == null) {
			throw new Error();
		}
		for (int i=0; i<in.length; i++) {
			if (in[i] > max) {
				max = in[i];	
			}
		}
		return max;
	}
	static private float Min(float in[]) {
		float min = Float.POSITIVE_INFINITY;
		if (in == null) {
			throw new Error();
		}
		for (int i=0; i<in.length; i++) {
			if (in[i] < min) {
				min = in[i];	
			}
		}
		return min;
	}
	static private int Min(int in[]) {
		int min = Integer.MAX_VALUE;
		if (in == null) {
			throw new Error();
		}
		for (int i=0; i<in.length; i++) {
			if (in[i] < min) {
				min = in[i];	
			}
		}
		return min;
	}
	static private byte Max(byte in[]) {
		byte max = Byte.MIN_VALUE;
		if (in == null) {
			throw new Error();
		}
		for (int i=0; i<in.length; i++) {
			if (in[i] > max) {
				max = in[i];	
			}
		}
		return max;
	}
	static private byte Min(byte in[]) {
		byte min = Byte.MAX_VALUE;
		if (in == null) {
			throw new Error();
		}
		for (int i=0; i<in.length; i++) {
			if (in[i] < min) {
				min = in[i];	
			}
		}
		return min;
	}

	
	public static SfpImage RGBtoHSL(SfpImage in) {
		int size = in.getHeight()*in.getWidth();
		SfpImage out = new SfpImage(in.getWidth(), in.getHeight());
		System.out.println(in.getHeight());
		System.out.println(size);
		float outData[] = out.getData();
		float inData[] = in.getData();
		float[] hsbvals = new float[3];
		for (int i=0; i<size; i++) {
			Color.RGBtoHSB((int)(inData[3*i]), (int)inData[3*i+1], (int)inData[3*i+2], hsbvals);
			// copy the results in the buffer
			for (int j=0;j<3;j++) {
				outData[3*i+j] = hsbvals[j];
			}
		}
		return out;
	}
	
	public static SfpImage RGBtoYxy(RgbImage in) {
		  double result[] = new double[3];
		  double X, Y, Z, W;
		  int totalLength = in.getHeight()*in.getWidth();
		  SfpImage out = new SfpImage(in.getWidth(), in.getHeight());
		  float outData[] = out.getData();
		  int inData[] = in.getData(); 
		  int c[] = new int[3];
		  for (int p=0; p<totalLength; p++) {
			  result[0] = result[1] = result[2] = 0.;
			  c[0] = RgbVal.getR(rgbData[i][p])-Byte.MIN_VALUE;
			  c[1] = RgbVal.getG(rgbData[i][p])-Byte.MIN_VALUE;
			  c[2] = RgbVal.getB(rgbData[i][p])-Byte.MIN_VALUE;
			  for (int i = 0; i < 3; i++) {
					for (int j = 0; j < 3; j++) {
						result[i] += RGB2XYZ[i][j] * c[j];
					}
			  }
			  W = result[0] + result[1] + result[2];
			  if (W > 0) {
				  outData[y][x][0] = result[1];         /* Y */
				  outData[y][x][1] = result[0] / W;     /* x */
				  outData[y][x][2] = result[1] / W;     /* y */
		      } else {
		    	  image[y][x][0] = image[y][x][1] = image[y][x][2] = 0;
		      }
		  }			      
	}
	public static double ComputeLogLuminance(SfpImage in) {
		// TODO(johmathe): assert image is type YSB
		// We don't use the java coding standards to get as close as possible to the paper reinhard2002
		double sumLog = 0;
		float inData[] = in.getData();
		int imSize = in.getHeight()*in.getWidth();
		System.out.println("d:" + d);
		for (int i=0; i<imSize; i++) {
			// Luminance is third component in YSB
			// TODO(johmathe): implement functions like getLuminance?
			sumLog += Math.log(inData[3*i+2]+d);
		}
		double Lw = Math.exp(sumLog/imSize);
		return Lw;
	}
	
	public static RgbImage ComputeNewLuminanceMap(SfpImage in) {
		// ToneMapping per se.
		double Lw = ComputeLogLuminance(in);
		System.out.println("Log luminance: "+Lw);
		RgbImage out = new RgbImage(in.getWidth(), in.getHeight());
		float inData[] = in.getData();
		int outData[] = out.getData();
		int imSize = in.getHeight()*in.getWidth();
		double tmpL;
		double l=0;
		float L[] = new float[imSize];
		for (int i=0; i<imSize; i++) {
			tmpL = (a/Lw)*inData[3*i+2];
			l = tmpL/(1+tmpL);
			//l = Math.log(inData[3*i+2]+d);
			L[i] = (float)(l);			
		}
		L = Normalize(L); 
		for (int i=0; i<imSize; i++) {	
			outData[i] = ConvertToRGB(inData[3*i], inData[3*i+1], (double)(L[i]));
		}		
		
		return out;
	}
	public static float[] Normalize(float v[]) {
		float min = Min(v);
		float delta = Max(v) - Min(v);
		float res[] = new float[v.length];
		for(int i=0; i<v.length; i++) {
			res[i] = (v[i] - min)/delta;
		}
		return res;
	}
	public static int ConvertToRGBGray(double v) {
		
		return RgbVal.toRgb((byte)(255*v-128), (byte)(255*v-128), (byte)(255*v-128));
	}
	public static int ConvertToRGB(double h, double s, double v) {
		return Color.HSBtoRGB((float)(h), (float)(s), (float)(v));
	}	
	
}
